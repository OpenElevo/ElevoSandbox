// This file is @generated by prost-build.
/// Sandbox resource
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Sandbox {
    /// Unique identifier
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Workspace ID this sandbox is bound to
    #[prost(string, tag = "2")]
    pub workspace_id: ::prost::alloc::string::String,
    /// Optional human-readable name
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Template used to create this sandbox
    #[prost(string, tag = "4")]
    pub template: ::prost::alloc::string::String,
    /// Current state
    #[prost(enumeration = "SandboxState", tag = "5")]
    pub state: i32,
    /// Environment variables
    #[prost(map = "string, string", tag = "6")]
    pub env: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Custom metadata
    #[prost(map = "string, string", tag = "7")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Creation timestamp
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Last update timestamp
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Timeout in seconds (0 = no timeout)
    #[prost(uint64, tag = "10")]
    pub timeout: u64,
    /// Error message (if state is ERROR)
    #[prost(string, optional, tag = "11")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
}
/// Create sandbox request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSandboxRequest {
    /// Workspace ID to bind to (required)
    #[prost(string, tag = "1")]
    pub workspace_id: ::prost::alloc::string::String,
    /// Template to use (optional, defaults to "default")
    #[prost(string, optional, tag = "2")]
    pub template: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional name
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Environment variables
    #[prost(map = "string, string", tag = "4")]
    pub env: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Custom metadata
    #[prost(map = "string, string", tag = "5")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Timeout in seconds (optional)
    #[prost(uint64, optional, tag = "6")]
    pub timeout: ::core::option::Option<u64>,
}
/// Create sandbox response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSandboxResponse {
    #[prost(message, optional, tag = "1")]
    pub sandbox: ::core::option::Option<Sandbox>,
}
/// Get sandbox request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSandboxRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Get sandbox response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSandboxResponse {
    #[prost(message, optional, tag = "1")]
    pub sandbox: ::core::option::Option<Sandbox>,
}
/// List sandboxes request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSandboxesRequest {
    /// Filter by state (optional)
    #[prost(enumeration = "SandboxState", optional, tag = "1")]
    pub state: ::core::option::Option<i32>,
    /// Pagination: page size
    #[prost(int32, optional, tag = "2")]
    pub page_size: ::core::option::Option<i32>,
    /// Pagination: page token
    #[prost(string, optional, tag = "3")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
}
/// List sandboxes response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSandboxesResponse {
    #[prost(message, repeated, tag = "1")]
    pub sandboxes: ::prost::alloc::vec::Vec<Sandbox>,
    /// Next page token (empty if no more pages)
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total count
    #[prost(int32, tag = "3")]
    pub total: i32,
}
/// Delete sandbox request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSandboxRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Force delete even if running
    #[prost(bool, tag = "2")]
    pub force: bool,
}
/// Delete sandbox response
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteSandboxResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
/// Sandbox state enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SandboxState {
    Unspecified = 0,
    Starting = 1,
    Running = 2,
    Stopping = 3,
    Stopped = 4,
    Error = 5,
}
impl SandboxState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SANDBOX_STATE_UNSPECIFIED",
            Self::Starting => "SANDBOX_STATE_STARTING",
            Self::Running => "SANDBOX_STATE_RUNNING",
            Self::Stopping => "SANDBOX_STATE_STOPPING",
            Self::Stopped => "SANDBOX_STATE_STOPPED",
            Self::Error => "SANDBOX_STATE_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SANDBOX_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "SANDBOX_STATE_STARTING" => Some(Self::Starting),
            "SANDBOX_STATE_RUNNING" => Some(Self::Running),
            "SANDBOX_STATE_STOPPING" => Some(Self::Stopping),
            "SANDBOX_STATE_STOPPED" => Some(Self::Stopped),
            "SANDBOX_STATE_ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
/// Generated server implementations.
pub mod sandbox_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SandboxServiceServer.
    #[async_trait]
    pub trait SandboxService: std::marker::Send + std::marker::Sync + 'static {
        /// Create a new sandbox
        async fn create_sandbox(
            &self,
            request: tonic::Request<super::CreateSandboxRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateSandboxResponse>,
            tonic::Status,
        >;
        /// Get sandbox by ID
        async fn get_sandbox(
            &self,
            request: tonic::Request<super::GetSandboxRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSandboxResponse>,
            tonic::Status,
        >;
        /// List all sandboxes
        async fn list_sandboxes(
            &self,
            request: tonic::Request<super::ListSandboxesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSandboxesResponse>,
            tonic::Status,
        >;
        /// Delete a sandbox
        async fn delete_sandbox(
            &self,
            request: tonic::Request<super::DeleteSandboxRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteSandboxResponse>,
            tonic::Status,
        >;
    }
    /// Sandbox service for managing sandbox lifecycle
    #[derive(Debug)]
    pub struct SandboxServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SandboxServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for SandboxServiceServer<T>
    where
        T: SandboxService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/workspace.v1.SandboxService/CreateSandbox" => {
                    #[allow(non_camel_case_types)]
                    struct CreateSandboxSvc<T: SandboxService>(pub Arc<T>);
                    impl<
                        T: SandboxService,
                    > tonic::server::UnaryService<super::CreateSandboxRequest>
                    for CreateSandboxSvc<T> {
                        type Response = super::CreateSandboxResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateSandboxRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SandboxService>::create_sandbox(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateSandboxSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/workspace.v1.SandboxService/GetSandbox" => {
                    #[allow(non_camel_case_types)]
                    struct GetSandboxSvc<T: SandboxService>(pub Arc<T>);
                    impl<
                        T: SandboxService,
                    > tonic::server::UnaryService<super::GetSandboxRequest>
                    for GetSandboxSvc<T> {
                        type Response = super::GetSandboxResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSandboxRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SandboxService>::get_sandbox(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSandboxSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/workspace.v1.SandboxService/ListSandboxes" => {
                    #[allow(non_camel_case_types)]
                    struct ListSandboxesSvc<T: SandboxService>(pub Arc<T>);
                    impl<
                        T: SandboxService,
                    > tonic::server::UnaryService<super::ListSandboxesRequest>
                    for ListSandboxesSvc<T> {
                        type Response = super::ListSandboxesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListSandboxesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SandboxService>::list_sandboxes(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListSandboxesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/workspace.v1.SandboxService/DeleteSandbox" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteSandboxSvc<T: SandboxService>(pub Arc<T>);
                    impl<
                        T: SandboxService,
                    > tonic::server::UnaryService<super::DeleteSandboxRequest>
                    for DeleteSandboxSvc<T> {
                        type Response = super::DeleteSandboxResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteSandboxRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SandboxService>::delete_sandbox(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteSandboxSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SandboxServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "workspace.v1.SandboxService";
    impl<T> tonic::server::NamedService for SandboxServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Run command request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunCommandRequest {
    /// Sandbox ID
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
    /// Command to execute
    #[prost(string, tag = "2")]
    pub command: ::prost::alloc::string::String,
    /// Command arguments
    #[prost(string, repeated, tag = "3")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Environment variables
    #[prost(map = "string, string", tag = "4")]
    pub env: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Working directory (optional)
    #[prost(string, optional, tag = "5")]
    pub cwd: ::core::option::Option<::prost::alloc::string::String>,
    /// Timeout in milliseconds (optional, 0 = no timeout)
    #[prost(uint64, optional, tag = "6")]
    pub timeout_ms: ::core::option::Option<u64>,
}
/// Run command response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunCommandResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<CommandResult>,
}
/// Command result
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandResult {
    /// Exit code
    #[prost(int32, tag = "1")]
    pub exit_code: i32,
    /// Standard output
    #[prost(string, tag = "2")]
    pub stdout: ::prost::alloc::string::String,
    /// Standard error
    #[prost(string, tag = "3")]
    pub stderr: ::prost::alloc::string::String,
}
/// Process event for streaming
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessEvent {
    #[prost(oneof = "process_event::Event", tags = "1, 2, 3, 4")]
    pub event: ::core::option::Option<process_event::Event>,
}
/// Nested message and enum types in `ProcessEvent`.
pub mod process_event {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Stdout(super::StdoutEvent),
        #[prost(message, tag = "2")]
        Stderr(super::StderrEvent),
        #[prost(message, tag = "3")]
        Exit(super::ExitEvent),
        #[prost(message, tag = "4")]
        Error(super::ErrorEvent),
    }
}
/// Stdout event
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StdoutEvent {
    #[prost(string, tag = "1")]
    pub data: ::prost::alloc::string::String,
}
/// Stderr event
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StderrEvent {
    #[prost(string, tag = "1")]
    pub data: ::prost::alloc::string::String,
}
/// Exit event
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExitEvent {
    #[prost(int32, tag = "1")]
    pub code: i32,
}
/// Error event
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorEvent {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
/// Kill process request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KillProcessRequest {
    /// Sandbox ID
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
    /// Process ID to kill
    #[prost(uint32, tag = "2")]
    pub pid: u32,
    /// Signal to send (default: SIGTERM = 15)
    #[prost(int32, optional, tag = "3")]
    pub signal: ::core::option::Option<i32>,
}
/// Kill process response
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KillProcessResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
/// Generated server implementations.
pub mod process_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ProcessServiceServer.
    #[async_trait]
    pub trait ProcessService: std::marker::Send + std::marker::Sync + 'static {
        /// Run a command and wait for completion
        async fn run_command(
            &self,
            request: tonic::Request<super::RunCommandRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RunCommandResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the RunCommandStream method.
        type RunCommandStreamStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ProcessEvent, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Run a command with streaming output
        async fn run_command_stream(
            &self,
            request: tonic::Request<super::RunCommandRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::RunCommandStreamStream>,
            tonic::Status,
        >;
        /// Kill a running process
        async fn kill_process(
            &self,
            request: tonic::Request<super::KillProcessRequest>,
        ) -> std::result::Result<
            tonic::Response<super::KillProcessResponse>,
            tonic::Status,
        >;
    }
    /// Process service for executing commands in sandboxes
    #[derive(Debug)]
    pub struct ProcessServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ProcessServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ProcessServiceServer<T>
    where
        T: ProcessService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/workspace.v1.ProcessService/RunCommand" => {
                    #[allow(non_camel_case_types)]
                    struct RunCommandSvc<T: ProcessService>(pub Arc<T>);
                    impl<
                        T: ProcessService,
                    > tonic::server::UnaryService<super::RunCommandRequest>
                    for RunCommandSvc<T> {
                        type Response = super::RunCommandResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RunCommandRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProcessService>::run_command(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RunCommandSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/workspace.v1.ProcessService/RunCommandStream" => {
                    #[allow(non_camel_case_types)]
                    struct RunCommandStreamSvc<T: ProcessService>(pub Arc<T>);
                    impl<
                        T: ProcessService,
                    > tonic::server::ServerStreamingService<super::RunCommandRequest>
                    for RunCommandStreamSvc<T> {
                        type Response = super::ProcessEvent;
                        type ResponseStream = T::RunCommandStreamStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RunCommandRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProcessService>::run_command_stream(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RunCommandStreamSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/workspace.v1.ProcessService/KillProcess" => {
                    #[allow(non_camel_case_types)]
                    struct KillProcessSvc<T: ProcessService>(pub Arc<T>);
                    impl<
                        T: ProcessService,
                    > tonic::server::UnaryService<super::KillProcessRequest>
                    for KillProcessSvc<T> {
                        type Response = super::KillProcessResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::KillProcessRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProcessService>::kill_process(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = KillProcessSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ProcessServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "workspace.v1.ProcessService";
    impl<T> tonic::server::NamedService for ProcessServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Create PTY request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePtyRequest {
    /// Sandbox ID
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
    /// Terminal columns (default: 80)
    #[prost(uint32, optional, tag = "2")]
    pub cols: ::core::option::Option<u32>,
    /// Terminal rows (default: 24)
    #[prost(uint32, optional, tag = "3")]
    pub rows: ::core::option::Option<u32>,
    /// Shell to use (optional, defaults to /bin/bash)
    #[prost(string, optional, tag = "4")]
    pub shell: ::core::option::Option<::prost::alloc::string::String>,
    /// Environment variables
    #[prost(map = "string, string", tag = "5")]
    pub env: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Create PTY response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePtyResponse {
    #[prost(message, optional, tag = "1")]
    pub pty: ::core::option::Option<PtyInfo>,
}
/// PTY information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PtyInfo {
    /// PTY ID
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Sandbox ID
    #[prost(string, tag = "2")]
    pub sandbox_id: ::prost::alloc::string::String,
    /// Terminal columns
    #[prost(uint32, tag = "3")]
    pub cols: u32,
    /// Terminal rows
    #[prost(uint32, tag = "4")]
    pub rows: u32,
}
/// Resize PTY request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResizePtyRequest {
    /// Sandbox ID
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
    /// PTY ID
    #[prost(string, tag = "2")]
    pub pty_id: ::prost::alloc::string::String,
    /// New columns
    #[prost(uint32, tag = "3")]
    pub cols: u32,
    /// New rows
    #[prost(uint32, tag = "4")]
    pub rows: u32,
}
/// Resize PTY response
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResizePtyResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
/// Kill PTY request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KillPtyRequest {
    /// Sandbox ID
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
    /// PTY ID
    #[prost(string, tag = "2")]
    pub pty_id: ::prost::alloc::string::String,
}
/// Kill PTY response
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KillPtyResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
/// Generated server implementations.
pub mod pty_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with PtyServiceServer.
    #[async_trait]
    pub trait PtyService: std::marker::Send + std::marker::Sync + 'static {
        /// Create a new PTY
        async fn create_pty(
            &self,
            request: tonic::Request<super::CreatePtyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreatePtyResponse>,
            tonic::Status,
        >;
        /// Resize a PTY
        async fn resize_pty(
            &self,
            request: tonic::Request<super::ResizePtyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ResizePtyResponse>,
            tonic::Status,
        >;
        /// Kill a PTY
        async fn kill_pty(
            &self,
            request: tonic::Request<super::KillPtyRequest>,
        ) -> std::result::Result<tonic::Response<super::KillPtyResponse>, tonic::Status>;
    }
    /// PTY service for interactive terminal sessions
    #[derive(Debug)]
    pub struct PtyServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> PtyServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for PtyServiceServer<T>
    where
        T: PtyService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/workspace.v1.PtyService/CreatePty" => {
                    #[allow(non_camel_case_types)]
                    struct CreatePtySvc<T: PtyService>(pub Arc<T>);
                    impl<
                        T: PtyService,
                    > tonic::server::UnaryService<super::CreatePtyRequest>
                    for CreatePtySvc<T> {
                        type Response = super::CreatePtyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreatePtyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PtyService>::create_pty(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreatePtySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/workspace.v1.PtyService/ResizePty" => {
                    #[allow(non_camel_case_types)]
                    struct ResizePtySvc<T: PtyService>(pub Arc<T>);
                    impl<
                        T: PtyService,
                    > tonic::server::UnaryService<super::ResizePtyRequest>
                    for ResizePtySvc<T> {
                        type Response = super::ResizePtyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ResizePtyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PtyService>::resize_pty(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ResizePtySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/workspace.v1.PtyService/KillPty" => {
                    #[allow(non_camel_case_types)]
                    struct KillPtySvc<T: PtyService>(pub Arc<T>);
                    impl<
                        T: PtyService,
                    > tonic::server::UnaryService<super::KillPtyRequest>
                    for KillPtySvc<T> {
                        type Response = super::KillPtyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::KillPtyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PtyService>::kill_pty(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = KillPtySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for PtyServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "workspace.v1.PtyService";
    impl<T> tonic::server::NamedService for PtyServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Message from agent to server
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentMessage {
    #[prost(oneof = "agent_message::Message", tags = "1, 2, 3, 4")]
    pub message: ::core::option::Option<agent_message::Message>,
}
/// Nested message and enum types in `AgentMessage`.
pub mod agent_message {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Message {
        /// Initial handshake
        #[prost(message, tag = "1")]
        Handshake(super::AgentHandshake),
        /// Heartbeat
        #[prost(message, tag = "2")]
        Heartbeat(super::AgentHeartbeat),
        /// Command response
        #[prost(message, tag = "3")]
        CommandResponse(super::AgentCommandResponse),
        /// PTY output
        #[prost(message, tag = "4")]
        PtyOutput(super::AgentPtyOutput),
    }
}
/// Agent handshake message
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentHandshake {
    /// Sandbox ID this agent belongs to
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
    /// Agent version
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
}
/// Agent heartbeat
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AgentHeartbeat {
    /// Timestamp in milliseconds
    #[prost(uint64, tag = "1")]
    pub timestamp: u64,
}
/// Command response from agent
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentCommandResponse {
    /// Correlation ID to match request
    #[prost(string, tag = "1")]
    pub correlation_id: ::prost::alloc::string::String,
    #[prost(oneof = "agent_command_response::Result", tags = "2, 3")]
    pub result: ::core::option::Option<agent_command_response::Result>,
}
/// Nested message and enum types in `AgentCommandResponse`.
pub mod agent_command_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        /// Successful result
        #[prost(message, tag = "2")]
        Success(super::AgentCommandSuccess),
        /// Error result
        #[prost(message, tag = "3")]
        Error(super::AgentCommandError),
    }
}
/// Successful command result
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentCommandSuccess {
    /// Exit code
    #[prost(int32, tag = "1")]
    pub exit_code: i32,
    /// Standard output
    #[prost(string, tag = "2")]
    pub stdout: ::prost::alloc::string::String,
    /// Standard error
    #[prost(string, tag = "3")]
    pub stderr: ::prost::alloc::string::String,
}
/// Command error
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentCommandError {
    /// Error code
    #[prost(int32, tag = "1")]
    pub code: i32,
    /// Error message
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// PTY output from agent
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentPtyOutput {
    /// PTY ID
    #[prost(string, tag = "1")]
    pub pty_id: ::prost::alloc::string::String,
    /// Output data
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Message from server to agent
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerMessage {
    #[prost(oneof = "server_message::Message", tags = "1, 2, 3, 4, 5, 6, 7, 8")]
    pub message: ::core::option::Option<server_message::Message>,
}
/// Nested message and enum types in `ServerMessage`.
pub mod server_message {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Message {
        /// Handshake acknowledgment
        #[prost(message, tag = "1")]
        HandshakeAck(super::ServerHandshakeAck),
        /// Heartbeat acknowledgment
        #[prost(message, tag = "2")]
        HeartbeatAck(super::ServerHeartbeatAck),
        /// Run command request
        #[prost(message, tag = "3")]
        RunCommand(super::AgentRunCommandRequest),
        /// Kill process request
        #[prost(message, tag = "4")]
        KillProcess(super::AgentKillProcessRequest),
        /// Create PTY request
        #[prost(message, tag = "5")]
        CreatePty(super::AgentCreatePtyRequest),
        /// Resize PTY request
        #[prost(message, tag = "6")]
        ResizePty(super::AgentResizePtyRequest),
        /// Kill PTY request
        #[prost(message, tag = "7")]
        KillPty(super::AgentKillPtyRequest),
        /// PTY input
        #[prost(message, tag = "8")]
        PtyInput(super::AgentPtyInput),
    }
}
/// Server handshake acknowledgment
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerHandshakeAck {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, optional, tag = "2")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
}
/// Server heartbeat acknowledgment
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServerHeartbeatAck {
    #[prost(uint64, tag = "1")]
    pub timestamp: u64,
}
/// Run command request for agent
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentRunCommandRequest {
    /// Correlation ID for matching response
    #[prost(string, tag = "1")]
    pub correlation_id: ::prost::alloc::string::String,
    /// Command to execute
    #[prost(string, tag = "2")]
    pub command: ::prost::alloc::string::String,
    /// Command arguments
    #[prost(string, repeated, tag = "3")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Environment variables
    #[prost(map = "string, string", tag = "4")]
    pub env: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Working directory (optional)
    #[prost(string, optional, tag = "5")]
    pub cwd: ::core::option::Option<::prost::alloc::string::String>,
    /// Timeout in milliseconds (0 = no timeout)
    #[prost(uint64, tag = "6")]
    pub timeout_ms: u64,
    /// Whether to stream output
    #[prost(bool, tag = "7")]
    pub stream: bool,
}
/// Kill process request for agent
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentKillProcessRequest {
    /// Correlation ID
    #[prost(string, tag = "1")]
    pub correlation_id: ::prost::alloc::string::String,
    /// Process ID
    #[prost(uint32, tag = "2")]
    pub pid: u32,
    /// Signal (default: SIGTERM = 15)
    #[prost(int32, tag = "3")]
    pub signal: i32,
}
/// Create PTY request for agent
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentCreatePtyRequest {
    /// Correlation ID
    #[prost(string, tag = "1")]
    pub correlation_id: ::prost::alloc::string::String,
    /// PTY ID (generated by server)
    #[prost(string, tag = "2")]
    pub pty_id: ::prost::alloc::string::String,
    /// Columns
    #[prost(uint32, tag = "3")]
    pub cols: u32,
    /// Rows
    #[prost(uint32, tag = "4")]
    pub rows: u32,
    /// Shell
    #[prost(string, optional, tag = "5")]
    pub shell: ::core::option::Option<::prost::alloc::string::String>,
    /// Environment variables
    #[prost(map = "string, string", tag = "6")]
    pub env: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Resize PTY request for agent
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentResizePtyRequest {
    /// Correlation ID
    #[prost(string, tag = "1")]
    pub correlation_id: ::prost::alloc::string::String,
    /// PTY ID
    #[prost(string, tag = "2")]
    pub pty_id: ::prost::alloc::string::String,
    /// New columns
    #[prost(uint32, tag = "3")]
    pub cols: u32,
    /// New rows
    #[prost(uint32, tag = "4")]
    pub rows: u32,
}
/// Kill PTY request for agent
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentKillPtyRequest {
    /// Correlation ID
    #[prost(string, tag = "1")]
    pub correlation_id: ::prost::alloc::string::String,
    /// PTY ID
    #[prost(string, tag = "2")]
    pub pty_id: ::prost::alloc::string::String,
}
/// PTY input from server to agent
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentPtyInput {
    /// PTY ID
    #[prost(string, tag = "1")]
    pub pty_id: ::prost::alloc::string::String,
    /// Input data
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Generated server implementations.
pub mod agent_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AgentServiceServer.
    #[async_trait]
    pub trait AgentService: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the Connect method.
        type ConnectStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ServerMessage, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Bidirectional streaming connection from agent to server
        async fn connect(
            &self,
            request: tonic::Request<tonic::Streaming<super::AgentMessage>>,
        ) -> std::result::Result<tonic::Response<Self::ConnectStream>, tonic::Status>;
    }
    /// Agent service for bidirectional communication between server and sandbox agents
    #[derive(Debug)]
    pub struct AgentServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AgentServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AgentServiceServer<T>
    where
        T: AgentService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/workspace.v1.AgentService/Connect" => {
                    #[allow(non_camel_case_types)]
                    struct ConnectSvc<T: AgentService>(pub Arc<T>);
                    impl<
                        T: AgentService,
                    > tonic::server::StreamingService<super::AgentMessage>
                    for ConnectSvc<T> {
                        type Response = super::ServerMessage;
                        type ResponseStream = T::ConnectStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::AgentMessage>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AgentService>::connect(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ConnectSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AgentServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "workspace.v1.AgentService";
    impl<T> tonic::server::NamedService for AgentServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
